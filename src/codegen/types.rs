//! Type code generation

use std::collections::BTreeMap;

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::model::{IntentKind, TypeRef};
use crate::parser::IntentStore;

/// Generate types.rs content
pub fn generate_types(store: &IntentStore) -> String {
    let mut types: Vec<_> = store.types().into_iter().collect();
    types.sort_by(|a, b| a.name.cmp(&b.name));

    let mut tokens = TokenStream::new();

    // Header
    tokens.extend(quote! {
        // @generated by intent-engine v1.0
        // DO NOT EDIT â€” changes will be overwritten

        use serde::{Deserialize, Serialize};
        use std::collections::HashMap;
    });

    // Generate each type
    for doc in types {
        let Ok(spec) = doc.as_type_spec() else {
            continue;
        };

        let type_name = format_ident!("{}", &doc.name);
        let mut fields = Vec::new();
        let mut field_names: Vec<_> = spec.fields.keys().collect();
        field_names.sort();

        for field_name in field_names {
            let field_def = spec.fields.get(field_name).unwrap();
            let field_ident = format_ident!("{}", field_name);
            let field_type = type_ref_to_tokens(&field_def.field_type);

            // Wrap in Option if not required
            let field_type = if field_def.required {
                field_type
            } else {
                quote! { Option<#field_type> }
            };

            // Add serde skip_serializing_if for optional fields
            let attrs = if !field_def.required {
                quote! {
                    #[serde(skip_serializing_if = "Option::is_none")]
                }
            } else {
                quote! {}
            };

            fields.push(quote! {
                #attrs
                pub #field_ident: #field_type,
            });
        }

        tokens.extend(quote! {
            #[derive(Debug, Clone, Serialize, Deserialize)]
            pub struct #type_name {
                #(#fields)*
            }
        });
    }

    // Format with prettyplease
    let file = syn::parse2(tokens).expect("Failed to parse generated code");
    prettyplease::unparse(&file)
}

/// Convert a TypeRef to a Rust type token stream
fn type_ref_to_tokens(type_ref: &TypeRef) -> TokenStream {
    match type_ref {
        TypeRef::String => quote! { String },
        TypeRef::Int => quote! { i64 },
        TypeRef::Float => quote! { f64 },
        TypeRef::Bool => quote! { bool },
        TypeRef::Money => quote! { rust_decimal::Decimal },
        TypeRef::DateTime => quote! { chrono::DateTime<chrono::Utc> },
        TypeRef::Uuid => quote! { uuid::Uuid },
        TypeRef::Bytes => quote! { Vec<u8> },
        TypeRef::Array(inner) => {
            let inner_tokens = type_ref_to_tokens(inner);
            quote! { Vec<#inner_tokens> }
        }
        TypeRef::Map(k, v) => {
            let k_tokens = type_ref_to_tokens(k);
            let v_tokens = type_ref_to_tokens(v);
            quote! { HashMap<#k_tokens, #v_tokens> }
        }
        TypeRef::Optional(inner) => {
            let inner_tokens = type_ref_to_tokens(inner);
            quote! { Option<#inner_tokens> }
        }
        TypeRef::Named(name) => {
            let ident = format_ident!("{}", name);
            quote! { #ident }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_type_ref_to_tokens() {
        let tokens = type_ref_to_tokens(&TypeRef::String);
        assert_eq!(tokens.to_string(), "String");

        let tokens = type_ref_to_tokens(&TypeRef::Array(Box::new(TypeRef::Int)));
        assert_eq!(tokens.to_string(), "Vec < i64 >");
    }
}
