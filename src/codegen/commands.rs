//! Code generation for Command intents

use crate::parser::IntentStore;

/// Generate Rust code for all Command intents (CLI structure)
pub fn generate_commands(store: &IntentStore) -> CommandsOutput {
    let mut commands: Vec<_> = store.commands().into_iter().collect();
    commands.sort_by(|a, b| a.name.cmp(&b.name));

    let mod_rs = generate_commands_mod(&commands);
    let cli_rs = generate_cli_main(&commands);
    let mut files = vec![CommandFile {
        name: "cli.rs".to_string(),
        content: cli_rs,
    }];

    for doc in &commands {
        if let Ok(spec) = doc.as_command_spec() {
            let content = generate_command_handler(&doc.name, &spec);
            files.push(CommandFile {
                name: format!("{}.rs", to_snake_case(&doc.name)),
                content,
            });
        }
    }

    CommandsOutput { mod_rs, files }
}

/// Output from command generation
pub struct CommandsOutput {
    pub mod_rs: String,
    pub files: Vec<CommandFile>,
}

/// A generated command file
pub struct CommandFile {
    pub name: String,
    pub content: String,
}

fn generate_commands_mod(commands: &[&crate::model::IntentDocument]) -> String {
    let mut output = String::new();

    output.push_str("// @generated by intent-engine v2.0\n");
    output.push_str("// DO NOT EDIT - changes will be overwritten\n\n");

    output.push_str("pub mod cli;\n");
    for doc in commands {
        output.push_str(&format!("pub mod {};\n", to_snake_case(&doc.name)));
    }

    output
}

fn generate_cli_main(commands: &[&crate::model::IntentDocument]) -> String {
    let mut output = String::new();

    output.push_str("// @generated by intent-engine v2.0\n");
    output.push_str("// DO NOT EDIT - changes will be overwritten\n\n");

    output.push_str("use clap::{Parser, Subcommand};\n\n");

    // Main CLI struct
    output.push_str("#[derive(Parser)]\n");
    output.push_str("#[command(name = \"intent\")]\n");
    output.push_str("#[command(about = \"Intent-first programming system\")]\n");
    output.push_str("pub struct Cli {\n");
    output.push_str("    #[command(subcommand)]\n");
    output.push_str("    pub command: Commands,\n");
    output.push_str("\n");
    output.push_str("    /// Output format\n");
    output.push_str("    #[arg(long, default_value = \"human\")]\n");
    output.push_str("    pub format: OutputFormat,\n");
    output.push_str("}\n\n");

    // Output format enum
    output.push_str("#[derive(Clone, Copy, Debug, clap::ValueEnum)]\n");
    output.push_str("pub enum OutputFormat {\n");
    output.push_str("    Human,\n");
    output.push_str("    Json,\n");
    output.push_str("}\n\n");

    // Commands enum
    output.push_str("#[derive(Subcommand)]\n");
    output.push_str("pub enum Commands {\n");

    for doc in commands {
        if let Ok(spec) = doc.as_command_spec() {
            // Doc comment
            if !spec.description.is_empty() {
                output.push_str(&format!("    /// {}\n", spec.description));
            }

            // Command variant
            let variant_name = to_pascal_case(&spec.command);
            let struct_name = format!("{}Args", variant_name);
            output.push_str(&format!("    {}({}),\n", variant_name, struct_name));
        }
    }

    output.push_str("}\n\n");

    // Args structs
    for doc in commands {
        if let Ok(spec) = doc.as_command_spec() {
            output.push_str(&generate_args_struct(&spec));
            output.push('\n');
        }
    }

    // Run function
    output.push_str("pub fn run(cli: Cli) -> anyhow::Result<i32> {\n");
    output.push_str("    match cli.command {\n");
    for doc in commands {
        if let Ok(spec) = doc.as_command_spec() {
            let variant_name = to_pascal_case(&spec.command);
            let module_name = to_snake_case(&doc.name);
            output.push_str(&format!(
                "        Commands::{}(args) => super::{}::run(args, cli.format),\n",
                variant_name, module_name
            ));
        }
    }
    output.push_str("    }\n");
    output.push_str("}\n");

    output
}

fn generate_args_struct(spec: &crate::model::CommandSpec) -> String {
    let mut output = String::new();

    let struct_name = format!("{}Args", to_pascal_case(&spec.command));

    output.push_str("#[derive(Parser)]\n");
    output.push_str(&format!("pub struct {} {{\n", struct_name));

    for arg in &spec.args {
        // Doc comment
        if !arg.description.is_empty() {
            output.push_str(&format!("    /// {}\n", arg.description));
        }

        // Argument attribute
        if arg.positional {
            output.push_str("    #[arg]\n");
        } else {
            let mut attrs = Vec::new();
            if let Some(short) = &arg.short {
                attrs.push(format!("short = '{}'", short));
            }
            if let Some(long) = &arg.long {
                attrs.push(format!("long = \"{}\"", long));
            }
            if let Some(default) = &arg.default {
                let default_str = match default {
                    serde_json::Value::Bool(b) => b.to_string(),
                    serde_json::Value::Number(n) => n.to_string(),
                    serde_json::Value::String(s) => format!("\"{}\"", s),
                    _ => "None".to_string(),
                };
                attrs.push(format!("default_value = \"{}\"", default_str));
            }
            if !arg.possible_values.is_empty() {
                let values: Vec<String> = arg
                    .possible_values
                    .iter()
                    .map(|v| format!("\"{}\"", v))
                    .collect();
                attrs.push(format!("value_parser = [{}]", values.join(", ")));
            }
            output.push_str(&format!("    #[arg({})]\n", attrs.join(", ")));
        }

        // Field
        let rust_type = match arg.arg_type.as_str() {
            "bool" => "bool".to_string(),
            "string" => {
                if arg.required {
                    "String".to_string()
                } else {
                    "Option<String>".to_string()
                }
            }
            "int" | "i32" => {
                if arg.required {
                    "i32".to_string()
                } else {
                    "Option<i32>".to_string()
                }
            }
            "int64" | "i64" => {
                if arg.required {
                    "i64".to_string()
                } else {
                    "Option<i64>".to_string()
                }
            }
            other => other.to_string(),
        };
        output.push_str(&format!("    pub {}: {},\n", arg.name, rust_type));
    }

    output.push_str("}\n");

    output
}

fn generate_command_handler(name: &str, spec: &crate::model::CommandSpec) -> String {
    let mut output = String::new();

    output.push_str("// @generated by intent-engine v2.0\n");
    output.push_str("// DO NOT EDIT - changes will be overwritten\n\n");

    let args_struct = format!("{}Args", to_pascal_case(&spec.command));

    output.push_str(&format!("use super::cli::{{{}}};\n", args_struct));
    output.push_str("use super::cli::OutputFormat;\n\n");

    // Doc comment
    if !spec.description.is_empty() {
        output.push_str(&format!("/// {}\n", spec.description));
    }

    output.push_str(&format!(
        "pub fn run(args: {}, format: OutputFormat) -> anyhow::Result<i32> {{\n",
        args_struct
    ));
    output.push_str(&format!("    // Handler: {}\n", spec.handler));
    output.push_str("    // TODO: Call the handler pipeline/function\n");
    output.push_str("    \n");

    // Generate exit code documentation
    output.push_str("    // Exit codes:\n");
    for exit in &spec.exit_codes {
        output.push_str(&format!("    // {} - {}\n", exit.code, exit.description));
    }

    output.push_str("    Ok(0)\n");
    output.push_str("}\n");

    output
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }
    result
}

fn to_pascal_case(s: &str) -> String {
    let mut result = String::new();
    let mut capitalize_next = true;
    for c in s.chars() {
        if c == '_' || c == '-' {
            capitalize_next = true;
        } else if capitalize_next {
            result.push(c.to_ascii_uppercase());
            capitalize_next = false;
        } else {
            result.push(c);
        }
    }
    result
}
