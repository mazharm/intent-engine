//! Error types code generation

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::parser::IntentStore;

/// Generate errors.rs content
pub fn generate_errors(store: &IntentStore) -> String {
    let mut endpoints: Vec<_> = store.endpoints().into_iter().collect();
    endpoints.sort_by(|a, b| a.name.cmp(&b.name));

    let mut error_enums = Vec::new();

    for doc in &endpoints {
        let Ok(spec) = doc.as_endpoint_spec() else {
            continue;
        };

        let error_name = format_ident!("{}Error", &doc.name);

        // Build error variants
        let mut variants = Vec::new();
        let mut status_arms = Vec::new();

        // Default errors if none specified
        let errors = if spec.errors.is_empty() {
            vec![
                crate::model::EndpointError {
                    code: "INVALID_INPUT".to_string(),
                    status: 400,
                    retryable: false,
                },
                crate::model::EndpointError {
                    code: "INTERNAL_ERROR".to_string(),
                    status: 500,
                    retryable: false,
                },
            ]
        } else {
            spec.errors.clone()
        };

        for error in &errors {
            let variant_name = format_ident!("{}", to_pascal_case(&error.code));
            let status = error.status;
            let display_msg = error.code.replace('_', " ").to_lowercase();

            variants.push(quote! {
                #[error(#display_msg)]
                #variant_name,
            });

            status_arms.push(quote! {
                Self::#variant_name => axum::http::StatusCode::from_u16(#status)
                    .unwrap_or(axum::http::StatusCode::INTERNAL_SERVER_ERROR),
            });
        }

        // Add anyhow error variant
        variants.push(quote! {
            #[error("internal error: {0}")]
            Internal(#[from] anyhow::Error),
        });

        status_arms.push(quote! {
            Self::Internal(_) => axum::http::StatusCode::INTERNAL_SERVER_ERROR,
        });

        error_enums.push(quote! {
            #[derive(Debug, thiserror::Error)]
            pub enum #error_name {
                #(#variants)*
            }

            impl axum::response::IntoResponse for #error_name {
                fn into_response(self) -> axum::response::Response {
                    let status = match &self {
                        #(#status_arms)*
                    };

                    let body = serde_json::json!({
                        "error": self.to_string(),
                    });

                    (status, axum::Json(body)).into_response()
                }
            }
        });
    }

    let tokens = quote! {
        // @generated by intent-engine v1.0
        // DO NOT EDIT â€” changes will be overwritten

        use axum::response::IntoResponse;

        #(#error_enums)*
    };

    let file = syn::parse2(tokens).expect("Failed to parse errors.rs");
    prettyplease::unparse(&file)
}

fn to_pascal_case(s: &str) -> String {
    s.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(c) => c.to_uppercase().chain(chars.flat_map(|c| c.to_lowercase())).collect(),
            }
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_pascal_case() {
        assert_eq!(to_pascal_case("INVALID_INPUT"), "InvalidInput");
        assert_eq!(to_pascal_case("NOT_FOUND"), "NotFound");
        assert_eq!(to_pascal_case("internal_error"), "InternalError");
    }
}
