//! Workflow code generation

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::model::{EffectKind, OnErrorStrategy, TypeRef, WorkflowStep};
use crate::parser::IntentStore;

/// Generate workflows module
pub fn generate_workflows(store: &IntentStore) -> WorkflowsOutput {
    let mut workflows: Vec<_> = store.workflows().into_iter().collect();
    workflows.sort_by(|a, b| a.name.cmp(&b.name));

    let mut output = WorkflowsOutput {
        mod_rs: String::new(),
        files: Vec::new(),
    };

    // Generate mod.rs
    let mut mod_decls = Vec::new();

    for doc in &workflows {
        let mod_name = to_snake_case(&doc.name);
        let mod_ident = format_ident!("{}", mod_name);

        mod_decls.push(quote! {
            pub mod #mod_ident;
        });
    }

    let mod_rs_tokens = quote! {
        // @generated by intent-engine v1.0
        // DO NOT EDIT — changes will be overwritten

        #(#mod_decls)*
    };

    let file = syn::parse2(mod_rs_tokens).expect("Failed to parse mod.rs");
    output.mod_rs = prettyplease::unparse(&file);

    // Generate individual workflow files
    for doc in &workflows {
        let Ok(spec) = doc.as_workflow_spec() else {
            continue;
        };

        let mod_name = to_snake_case(&doc.name);
        let fn_ident = format_ident!("{}", mod_name);
        let input_type = format_ident!("{}", &spec.input);
        let output_type = format_ident!("{}", &spec.output);

        // Generate context struct
        let mut context_fields = Vec::new();
        let mut context_defaults = Vec::new();
        let mut context_field_names: Vec<_> = spec.context.keys().collect();
        context_field_names.sort();

        for name in &context_field_names {
            let type_ref = spec.context.get(*name).unwrap();
            let field_ident = format_ident!("{}", name);
            let field_type = type_ref_to_tokens(type_ref);

            context_fields.push(quote! {
                pub #field_ident: Option<#field_type>,
            });
            context_defaults.push(quote! {
                #field_ident: None,
            });
        }

        // Generate steps
        let mut step_code = Vec::new();

        for (i, step) in spec.steps.iter().enumerate() {
            match step {
                WorkflowStep::Transform(t) => {
                    // Generate assignments
                    for (target, _source) in &t.assign {
                        let target_ident = format_ident!("{}", target);
                        // Simplified: in real impl, would parse and evaluate source expression
                        step_code.push(quote! {
                            // Step: #i - Transform
                            // context.#target_ident = Some(evaluate(#source));
                        });
                    }

                    // Generate raise_if
                    if let Some(raise) = &t.raise_if {
                        let error_code = &raise.error;
                        step_code.push(quote! {
                            // raise_if: #error_code
                            // if evaluate(condition) { return Err(error); }
                        });
                    }
                }
                WorkflowStep::Effect(e) => {
                    let effect_call = match e.effect {
                        EffectKind::HttpCall => {
                            let service = e.service.as_deref().unwrap_or("unknown");
                            let operation = e.operation.as_deref().unwrap_or("unknown");
                            quote! {
                                // HttpCall to #service.#operation
                                let _result = crate::effects::http::call(
                                    #service,
                                    #operation,
                                    &input,
                                ).await;
                            }
                        }
                        EffectKind::DbRead => {
                            let table = e.table.as_deref().unwrap_or("unknown");
                            quote! {
                                // DbRead from #table
                                let _result = crate::effects::db::read(#table, &context).await;
                            }
                        }
                        EffectKind::DbWrite => {
                            let table = e.table.as_deref().unwrap_or("unknown");
                            quote! {
                                // DbWrite to #table
                                crate::effects::db::write(#table, &context).await?;
                            }
                        }
                        EffectKind::DbDelete => {
                            let table = e.table.as_deref().unwrap_or("unknown");
                            quote! {
                                // DbDelete from #table
                                crate::effects::db::delete(#table, &context).await?;
                            }
                        }
                        EffectKind::EmitEvent => {
                            let topic = e.topic.as_deref().unwrap_or("unknown");
                            quote! {
                                // EmitEvent to #topic
                                crate::effects::events::emit(#topic, &context).await;
                            }
                        }
                    };

                    // Handle on_error
                    let wrapped = match e.on_error {
                        OnErrorStrategy::Abort => effect_call,
                        OnErrorStrategy::Continue => quote! {
                            if let Err(e) = (|| async { #effect_call })().await {
                                tracing::warn!("Effect failed, continuing: {:?}", e);
                            }
                        },
                        OnErrorStrategy::Retry => quote! {
                            // Retry logic would go here
                            #effect_call
                        },
                    };

                    step_code.push(wrapped);
                }
            }
        }

        let file_tokens = quote! {
            // @generated by intent-engine v1.0
            // DO NOT EDIT — changes will be overwritten

            use crate::types::{#input_type, #output_type};

            #[derive(Debug, Default)]
            struct Context {
                #(#context_fields)*
            }

            pub async fn #fn_ident(input: #input_type) -> Result<#output_type, anyhow::Error> {
                let mut context = Context {
                    #(#context_defaults)*
                };

                #(#step_code)*

                // TODO: Map context to output
                todo!("Map workflow result to output type")
            }
        };

        let file = syn::parse2(file_tokens).expect("Failed to parse workflow file");
        output.files.push(WorkflowFile {
            name: format!("{}.rs", mod_name),
            content: prettyplease::unparse(&file),
        });
    }

    output
}

pub struct WorkflowsOutput {
    pub mod_rs: String,
    pub files: Vec<WorkflowFile>,
}

pub struct WorkflowFile {
    pub name: String,
    pub content: String,
}

fn type_ref_to_tokens(type_ref: &TypeRef) -> TokenStream {
    match type_ref {
        TypeRef::String => quote! { String },
        TypeRef::Int => quote! { i64 },
        TypeRef::Float => quote! { f64 },
        TypeRef::Bool => quote! { bool },
        TypeRef::Money => quote! { rust_decimal::Decimal },
        TypeRef::DateTime => quote! { chrono::DateTime<chrono::Utc> },
        TypeRef::Uuid => quote! { uuid::Uuid },
        TypeRef::Bytes => quote! { Vec<u8> },
        TypeRef::Array(inner) => {
            let inner_tokens = type_ref_to_tokens(inner);
            quote! { Vec<#inner_tokens> }
        }
        TypeRef::Map(k, v) => {
            let k_tokens = type_ref_to_tokens(k);
            let v_tokens = type_ref_to_tokens(v);
            quote! { std::collections::HashMap<#k_tokens, #v_tokens> }
        }
        TypeRef::Optional(inner) => {
            let inner_tokens = type_ref_to_tokens(inner);
            quote! { Option<#inner_tokens> }
        }
        TypeRef::Named(name) => {
            let ident = format_ident!("{}", name);
            quote! { crate::types::#ident }
        }
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}
