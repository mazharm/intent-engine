//! Code generation for Function intents

use crate::model::{BinaryOp, Expression, Pattern, UnaryOp};
use crate::parser::IntentStore;

/// Generate Rust code for all Function intents
pub fn generate_functions(store: &IntentStore) -> String {
    let mut output = String::new();

    output.push_str("// @generated by intent-engine v2.0\n");
    output.push_str("// DO NOT EDIT - changes will be overwritten\n\n");

    let mut functions: Vec<_> = store.functions().into_iter().collect();
    functions.sort_by(|a, b| a.name.cmp(&b.name));

    for doc in functions {
        if let Ok(spec) = doc.as_function_spec() {
            output.push_str(&generate_function(&doc.name, &spec));
            output.push('\n');
        }
    }

    output
}

fn generate_function(name: &str, spec: &crate::model::FunctionSpec) -> String {
    let mut output = String::new();

    // Doc comment
    if !spec.description.is_empty() {
        output.push_str(&format!("/// {}\n", spec.description));
    }

    // Function signature
    let fn_name = to_snake_case(name);
    let generics = if spec.generics.is_empty() {
        String::new()
    } else {
        let params: Vec<String> = spec
            .generics
            .iter()
            .map(|g| {
                if g.bounds.is_empty() {
                    g.name.clone()
                } else {
                    format!("{}: {}", g.name, g.bounds.join(" + "))
                }
            })
            .collect();
        format!("<{}>", params.join(", "))
    };

    let params: Vec<String> = spec
        .parameters
        .iter()
        .map(|p| format!("{}: {}", p.name, p.param_type))
        .collect();

    output.push_str(&format!(
        "pub fn {}{}({}) -> {} {{\n",
        fn_name,
        generics,
        params.join(", "),
        spec.returns.return_type
    ));

    // Function body
    output.push_str(&generate_expression(&spec.body, 1));
    output.push_str("\n}\n");

    output
}

fn generate_expression(expr: &Expression, indent: usize) -> String {
    let indent_str = "    ".repeat(indent);

    match expr {
        Expression::Literal { value } => match value {
            serde_json::Value::Null => "None".to_string(),
            serde_json::Value::Bool(b) => b.to_string(),
            serde_json::Value::Number(n) => n.to_string(),
            serde_json::Value::String(s) => {
                // Check if it's a type reference like TypeRef::String
                if s.contains("::") {
                    s.clone()
                } else {
                    format!("\"{}\"", s.replace('\\', "\\\\").replace('"', "\\\""))
                }
            }
            serde_json::Value::Array(arr) => {
                let items: Vec<String> = arr
                    .iter()
                    .map(|v| {
                        generate_expression(
                            &Expression::Literal { value: v.clone() },
                            indent,
                        )
                    })
                    .collect();
                format!("vec![{}]", items.join(", "))
            }
            serde_json::Value::Object(_) => "/* complex object */".to_string(),
        },

        Expression::Variable { name } => name.clone(),

        Expression::Field { expr, name } => {
            format!("{}.{}", generate_expression(expr, indent), name)
        }

        Expression::Index { expr, index } => {
            format!(
                "{}[{}]",
                generate_expression(expr, indent),
                generate_expression(index, indent)
            )
        }

        Expression::Call { function, args } => {
            let args_str: Vec<String> = args
                .iter()
                .map(|a| generate_expression(a, indent))
                .collect();
            format!("{}({})", function, args_str.join(", "))
        }

        Expression::Method { expr, name, args } => {
            let args_str: Vec<String> = args
                .iter()
                .map(|a| generate_expression(a, indent))
                .collect();
            format!(
                "{}.{}({})",
                generate_expression(expr, indent),
                name,
                args_str.join(", ")
            )
        }

        Expression::Binary { op, left, right } => {
            let op_str = match op {
                BinaryOp::Add => "+",
                BinaryOp::Sub => "-",
                BinaryOp::Mul => "*",
                BinaryOp::Div => "/",
                BinaryOp::Mod => "%",
                BinaryOp::Eq => "==",
                BinaryOp::Ne => "!=",
                BinaryOp::Lt => "<",
                BinaryOp::Le => "<=",
                BinaryOp::Gt => ">",
                BinaryOp::Ge => ">=",
                BinaryOp::And => "&&",
                BinaryOp::Or => "||",
                BinaryOp::Concat => "+", // String concatenation in Rust uses format!
            };
            format!(
                "({} {} {})",
                generate_expression(left, indent),
                op_str,
                generate_expression(right, indent)
            )
        }

        Expression::Unary { op, expr } => {
            let op_str = match op {
                UnaryOp::Not => "!",
                UnaryOp::Neg => "-",
            };
            format!("{}{}", op_str, generate_expression(expr, indent))
        }

        Expression::If {
            cond,
            then_branch,
            else_branch,
        } => {
            format!(
                "if {} {{\n{}{}\n{}}} else {{\n{}{}\n{}}}",
                generate_expression(cond, indent),
                indent_str,
                generate_expression(then_branch, indent + 1),
                "    ".repeat(indent.saturating_sub(1)),
                indent_str,
                generate_expression(else_branch, indent + 1),
                "    ".repeat(indent.saturating_sub(1))
            )
        }

        Expression::Match { on, arms } => {
            let mut output = format!("match {} {{\n", generate_expression(on, indent));
            for arm in arms {
                output.push_str(&format!(
                    "{}    {} => {},\n",
                    "    ".repeat(indent.saturating_sub(1)),
                    generate_pattern(&arm.pattern),
                    generate_expression(&arm.body, indent + 1)
                ));
            }
            output.push_str(&format!("{}}}", "    ".repeat(indent.saturating_sub(1))));
            output
        }

        Expression::Let { bindings, body } => {
            let mut output = String::new();
            for binding in bindings {
                let type_ann = binding
                    .type_annotation
                    .as_ref()
                    .map(|t| format!(": {}", t))
                    .unwrap_or_default();
                output.push_str(&format!(
                    "let {}{} = {};\n{}",
                    binding.name,
                    type_ann,
                    generate_expression(&binding.value, indent),
                    indent_str
                ));
            }
            output.push_str(&generate_expression(body, indent));
            output
        }

        Expression::For { var, iterable, body } => {
            format!(
                "for {} in {} {{\n{}{}\n{}}}",
                var,
                generate_expression(iterable, indent),
                indent_str,
                generate_expression(body, indent + 1),
                "    ".repeat(indent.saturating_sub(1))
            )
        }

        Expression::Return { value } => {
            format!("return {}", generate_expression(value, indent))
        }

        Expression::Raise { error, message } => {
            if let Some(msg) = message {
                format!(
                    "return Err({}({}))",
                    error,
                    generate_expression(msg, indent)
                )
            } else {
                format!("return Err({})", error)
            }
        }

        Expression::Block { exprs } => {
            let stmts: Vec<String> = exprs
                .iter()
                .enumerate()
                .map(|(i, e)| {
                    let is_last = i == exprs.len() - 1;
                    let expr_str = generate_expression(e, indent);
                    if is_last {
                        expr_str
                    } else {
                        format!("{};", expr_str)
                    }
                })
                .collect();
            stmts.join(&format!("\n{}", indent_str))
        }

        Expression::Struct { name, fields } => {
            let field_strs: Vec<String> = fields
                .iter()
                .map(|(k, v)| format!("{}: {}", k, generate_expression(v, indent)))
                .collect();
            format!("{} {{ {} }}", name, field_strs.join(", "))
        }

        Expression::Array { elements } => {
            let items: Vec<String> = elements
                .iter()
                .map(|e| generate_expression(e, indent))
                .collect();
            format!("vec![{}]", items.join(", "))
        }

        Expression::Tuple { elements } => {
            let items: Vec<String> = elements
                .iter()
                .map(|e| generate_expression(e, indent))
                .collect();
            format!("({})", items.join(", "))
        }

        Expression::Closure { params, body } => {
            format!("|{}| {}", params.join(", "), generate_expression(body, indent))
        }

        Expression::Try { expr } => {
            format!("{}?", generate_expression(expr, indent))
        }

        Expression::UnwrapOr { expr, default } => {
            format!(
                "{}.unwrap_or({})",
                generate_expression(expr, indent),
                generate_expression(default, indent)
            )
        }
    }
}

fn generate_pattern(pattern: &Pattern) -> String {
    match pattern {
        Pattern::Wildcard => "_".to_string(),
        Pattern::Variable { name } => name.clone(),
        Pattern::Literal { value } => match value {
            serde_json::Value::Null => "None".to_string(),
            serde_json::Value::Bool(b) => b.to_string(),
            serde_json::Value::Number(n) => n.to_string(),
            serde_json::Value::String(s) => format!("\"{}\"", s),
            _ => "/* complex pattern */".to_string(),
        },
        Pattern::Variant {
            enum_name,
            variant,
            bindings,
        } => {
            let prefix = enum_name
                .as_ref()
                .map(|n| format!("{}::", n))
                .unwrap_or_default();
            if bindings.is_empty() {
                format!("{}{}", prefix, variant)
            } else {
                format!("{}{}({})", prefix, variant, bindings.join(", "))
            }
        }
        Pattern::Struct { name, fields } => {
            let field_pats: Vec<String> = fields
                .iter()
                .map(|(k, v)| format!("{}: {}", k, generate_pattern(v)))
                .collect();
            format!("{} {{ {} }}", name, field_pats.join(", "))
        }
        Pattern::Tuple { elements } => {
            let pats: Vec<String> = elements.iter().map(generate_pattern).collect();
            format!("({})", pats.join(", "))
        }
        Pattern::Array { elements, rest } => {
            let mut pats: Vec<String> = elements.iter().map(generate_pattern).collect();
            if let Some(r) = rest {
                pats.push(format!("{}@..", r));
            }
            format!("[{}]", pats.join(", "))
        }
        Pattern::StartsWith { prefix } => {
            format!("s if s.starts_with(\"{}\")", prefix)
        }
        Pattern::EndsWith { suffix } => {
            format!("s if s.ends_with(\"{}\")", suffix)
        }
        Pattern::Some { binding } => format!("Some({})", binding),
        Pattern::None => "None".to_string(),
        Pattern::Ok { binding } => format!("Ok({})", binding),
        Pattern::Err { binding } => format!("Err({})", binding),
        Pattern::Or { patterns } => {
            let pats: Vec<String> = patterns.iter().map(generate_pattern).collect();
            pats.join(" | ")
        }
    }
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }
    result
}
