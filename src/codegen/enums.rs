//! Code generation for Enum intents

use crate::model::VariantData;
use crate::parser::IntentStore;

/// Generate Rust code for all Enum intents
pub fn generate_enums(store: &IntentStore) -> String {
    let mut output = String::new();

    output.push_str("// @generated by intent-engine v2.0\n");
    output.push_str("// DO NOT EDIT - changes will be overwritten\n\n");

    output.push_str("use serde::{Deserialize, Serialize};\n\n");

    let mut enums: Vec<_> = store.enums().into_iter().collect();
    enums.sort_by(|a, b| a.name.cmp(&b.name));

    for doc in enums {
        if let Ok(spec) = doc.as_enum_spec() {
            output.push_str(&generate_enum(&doc.name, &spec));
            output.push('\n');
        }
    }

    output
}

fn generate_enum(name: &str, spec: &crate::model::EnumSpec) -> String {
    let mut output = String::new();

    // Doc comment
    if !spec.description.is_empty() {
        output.push_str(&format!("/// {}\n", spec.description));
    }

    // Derives
    let derives = if spec.derives.is_empty() {
        vec![
            "Debug".to_string(),
            "Clone".to_string(),
            "PartialEq".to_string(),
            "Eq".to_string(),
            "Serialize".to_string(),
            "Deserialize".to_string(),
        ]
    } else {
        spec.derives.clone()
    };
    output.push_str(&format!("#[derive({})]\n", derives.join(", ")));

    // Serde tag attribute
    if let Some(tag) = &spec.serde_tag {
        output.push_str(&format!("#[serde(tag = \"{}\")]\n", tag));
    }

    // Generic parameters
    let generics = if spec.generics.is_empty() {
        String::new()
    } else {
        let params: Vec<String> = spec
            .generics
            .iter()
            .map(|g| {
                if g.bounds.is_empty() {
                    g.name.clone()
                } else {
                    format!("{}: {}", g.name, g.bounds.join(" + "))
                }
            })
            .collect();
        format!("<{}>", params.join(", "))
    };

    output.push_str(&format!("pub enum {}{} {{\n", name, generics));

    // Variants
    for variant in &spec.variants {
        // Doc comment
        if !variant.description.is_empty() {
            output.push_str(&format!("    /// {}\n", variant.description));
        }

        // Serde rename
        if let Some(rename) = &variant.serde_rename {
            output.push_str(&format!("    #[serde(rename = \"{}\")]\n", rename));
        }

        // Variant definition
        match &variant.data {
            None => {
                output.push_str(&format!("    {},\n", variant.name));
            }
            Some(VariantData::Named(fields)) => {
                output.push_str(&format!("    {} {{\n", variant.name));
                for (field_name, field_type) in fields {
                    output.push_str(&format!("        {}: {},\n", field_name, field_type));
                }
                output.push_str("    },\n");
            }
            Some(VariantData::Tuple(types)) => {
                output.push_str(&format!("    {}({}),\n", variant.name, types.join(", ")));
            }
        }
    }

    output.push_str("}\n");

    output
}

/// Generate Rust code for a single Enum spec (for inline generation)
pub fn generate_enum_inline(name: &str, spec: &crate::model::EnumSpec) -> String {
    generate_enum(name, spec)
}
