//! Effects runtime code generation

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::parser::IntentStore;
use crate::parser::IntentConfig;

/// Generate effects module
pub fn generate_effects(store: &IntentStore, config: &IntentConfig) -> EffectsOutput {
    let mut output = EffectsOutput {
        mod_rs: String::new(),
        http_rs: String::new(),
        db_rs: String::new(),
        events_rs: String::new(),
    };

    // Generate mod.rs
    let mod_rs_tokens = quote! {
        // @generated by intent-engine v1.0
        // DO NOT EDIT — changes will be overwritten

        pub mod http;
        pub mod db;
        pub mod events;
    };

    let file = syn::parse2(mod_rs_tokens).expect("Failed to parse mod.rs");
    output.mod_rs = prettyplease::unparse(&file);

    // Generate http.rs
    let http_client = &config.runtime.http_client;
    output.http_rs = generate_http_module(store, http_client);

    // Generate db.rs
    let db_client = &config.runtime.db_client;
    output.db_rs = generate_db_module(db_client);

    // Generate events.rs
    let event_client = &config.runtime.event_client;
    output.events_rs = generate_events_module(event_client);

    output
}

fn generate_http_module(store: &IntentStore, client: &str) -> String {
    // Generate service clients
    let mut service_clients = Vec::new();

    for doc in store.services() {
        let Ok(spec) = doc.as_service_spec() else {
            continue;
        };

        let service_name = &doc.name;
        let base_url = &spec.base_url;
        let env_var = format!("{}_BASE_URL", service_name.to_uppercase());
        let fn_name = format_ident!("call_{}", service_name.to_lowercase());

        service_clients.push(quote! {
            pub async fn #fn_name(
                operation: &str,
                request: impl serde::Serialize,
            ) -> Result<serde_json::Value, HttpError> {
                let base_url = std::env::var(#env_var)
                    .unwrap_or_else(|_| #base_url.to_string());

                let client = reqwest::Client::new();
                // Operation routing would be added here
                let response = client
                    .post(&base_url)
                    .json(&request)
                    .send()
                    .await?;

                if response.status().is_success() {
                    Ok(response.json().await?)
                } else {
                    Err(HttpError::StatusError(response.status().as_u16()))
                }
            }
        });
    }

    let http_tokens = quote! {
        // @generated by intent-engine v1.0
        // DO NOT EDIT — changes will be overwritten

        use thiserror::Error;

        #[derive(Debug, Error)]
        pub enum HttpError {
            #[error("HTTP request failed: {0}")]
            Request(#[from] reqwest::Error),

            #[error("HTTP status error: {0}")]
            StatusError(u16),
        }

        pub async fn call(
            service: &str,
            operation: &str,
            request: &impl serde::Serialize,
        ) -> Result<serde_json::Value, HttpError> {
            // Service routing based on service name
            match service {
                _ => Err(HttpError::StatusError(404)),
            }
        }

        // Generated service-specific clients
        // #(#service_clients)*
    };

    let file = syn::parse2(http_tokens).expect("Failed to parse http.rs");
    prettyplease::unparse(&file)
}

fn generate_db_module(client: &str) -> String {
    let db_tokens = quote! {
        // @generated by intent-engine v1.0
        // DO NOT EDIT — changes will be overwritten

        use thiserror::Error;

        #[derive(Debug, Error)]
        pub enum DbError {
            #[error("Database error: {0}")]
            Database(String),

            #[error("Not found")]
            NotFound,
        }

        pub async fn read<T>(table: &str, query: &impl serde::Serialize) -> Result<T, DbError>
        where
            T: serde::de::DeserializeOwned,
        {
            // Database read implementation using sqlx
            todo!("Implement database read")
        }

        pub async fn write(table: &str, data: &impl serde::Serialize) -> Result<(), DbError> {
            // Database write implementation using sqlx
            todo!("Implement database write")
        }

        pub async fn delete(table: &str, query: &impl serde::Serialize) -> Result<(), DbError> {
            // Database delete implementation using sqlx
            todo!("Implement database delete")
        }
    };

    let file = syn::parse2(db_tokens).expect("Failed to parse db.rs");
    prettyplease::unparse(&file)
}

fn generate_events_module(client: &str) -> String {
    let events_tokens = quote! {
        // @generated by intent-engine v1.0
        // DO NOT EDIT — changes will be overwritten

        use thiserror::Error;

        #[derive(Debug, Error)]
        pub enum EventError {
            #[error("Event publish failed: {0}")]
            Publish(String),
        }

        pub async fn emit(topic: &str, payload: &impl serde::Serialize) -> Result<(), EventError> {
            // Event emission implementation
            tracing::info!("Emitting event to topic: {}", topic);
            Ok(())
        }
    };

    let file = syn::parse2(events_tokens).expect("Failed to parse events.rs");
    prettyplease::unparse(&file)
}

pub struct EffectsOutput {
    pub mod_rs: String,
    pub http_rs: String,
    pub db_rs: String,
    pub events_rs: String,
}
