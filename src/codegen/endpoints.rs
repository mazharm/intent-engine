//! Endpoint code generation

use proc_macro2::TokenStream;
use quote::{format_ident, quote};

use crate::model::HttpMethod;
use crate::parser::IntentStore;

/// Generate endpoints module
pub fn generate_endpoints(store: &IntentStore) -> EndpointsOutput {
    let mut endpoints: Vec<_> = store.endpoints().into_iter().collect();
    endpoints.sort_by(|a, b| a.name.cmp(&b.name));

    let mut output = EndpointsOutput {
        mod_rs: String::new(),
        files: Vec::new(),
    };

    // Generate mod.rs
    let mut mod_decls = Vec::new();
    let mut router_routes = Vec::new();

    for doc in &endpoints {
        let Ok(spec) = doc.as_endpoint_spec() else {
            continue;
        };

        let mod_name = to_snake_case(&doc.name);
        let mod_ident = format_ident!("{}", mod_name);
        let handler_ident = format_ident!("{}", mod_name);

        mod_decls.push(quote! {
            pub mod #mod_ident;
        });

        let path = &spec.path;
        let route = match spec.method {
            HttpMethod::Get => quote! { .route(#path, axum::routing::get(#mod_ident::#handler_ident)) },
            HttpMethod::Post => quote! { .route(#path, axum::routing::post(#mod_ident::#handler_ident)) },
            HttpMethod::Put => quote! { .route(#path, axum::routing::put(#mod_ident::#handler_ident)) },
            HttpMethod::Patch => quote! { .route(#path, axum::routing::patch(#mod_ident::#handler_ident)) },
            HttpMethod::Delete => quote! { .route(#path, axum::routing::delete(#mod_ident::#handler_ident)) },
        };
        router_routes.push(route);
    }

    let mod_rs_tokens = quote! {
        // @generated by intent-engine v1.0
        // DO NOT EDIT — changes will be overwritten

        #(#mod_decls)*

        use axum::Router;

        pub fn router() -> Router {
            Router::new()
                #(#router_routes)*
        }
    };

    let file = syn::parse2(mod_rs_tokens).expect("Failed to parse mod.rs");
    output.mod_rs = prettyplease::unparse(&file);

    // Generate individual endpoint files
    for doc in &endpoints {
        let Ok(spec) = doc.as_endpoint_spec() else {
            continue;
        };

        let mod_name = to_snake_case(&doc.name);
        let handler_ident = format_ident!("{}", mod_name);
        let input_type = format_ident!("{}", &spec.input);
        let output_type = format_ident!("{}", &spec.output);
        let workflow_mod = format_ident!("{}", to_snake_case(&spec.workflow));
        let workflow_fn = format_ident!("{}", to_snake_case(&spec.workflow));
        let error_type = format_ident!("{}Error", &doc.name);

        // Generate timeout middleware if specified
        let timeout_layer = if let Some(timeout_ms) = spec.policies.timeout_ms {
            quote! {
                // Timeout: #timeout_ms ms
                let _timeout = std::time::Duration::from_millis(#timeout_ms as u64);
            }
        } else {
            quote! {}
        };

        let file_tokens = quote! {
            // @generated by intent-engine v1.0
            // DO NOT EDIT — changes will be overwritten
            // source: #mod_name

            use axum::{extract::State, Json};
            use crate::types::{#input_type, #output_type};
            use crate::workflows::#workflow_mod;
            use crate::errors::#error_type;

            pub async fn #handler_ident(
                Json(input): Json<#input_type>,
            ) -> Result<Json<#output_type>, #error_type> {
                #timeout_layer

                let result = #workflow_mod::#workflow_fn(input).await?;
                Ok(Json(result))
            }
        };

        let file = syn::parse2(file_tokens).expect("Failed to parse endpoint file");
        output.files.push(EndpointFile {
            name: format!("{}.rs", mod_name),
            content: prettyplease::unparse(&file),
        });
    }

    output
}

pub struct EndpointsOutput {
    pub mod_rs: String,
    pub files: Vec<EndpointFile>,
}

pub struct EndpointFile {
    pub name: String,
    pub content: String,
}

fn to_snake_case(s: &str) -> String {
    let mut result = String::new();
    for (i, c) in s.chars().enumerate() {
        if c.is_uppercase() {
            if i > 0 {
                result.push('_');
            }
            result.push(c.to_lowercase().next().unwrap());
        } else {
            result.push(c);
        }
    }
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_to_snake_case() {
        assert_eq!(to_snake_case("CreateRefund"), "create_refund");
        assert_eq!(to_snake_case("HTTPHandler"), "h_t_t_p_handler");
        assert_eq!(to_snake_case("test"), "test");
    }
}
